/*
 * Teensy 4.0 I2C Host — ATtiny804 Triple Encoder Reader
 *
 * Reads three encoder positions and button states from the ATtiny804 I2C slave.
 * Uses the INT pin to only read when there's new data (interrupt-driven),
 * with a fallback periodic poll.
 *
 * Uses unsigned subtraction to compute deltas from the slave's running
 * counter, which correctly handles int16_t wraparound without needing
 * reset commands.
 *
 * Connections:
 *   Teensy Pin 18 (SDA) <-> ATtiny804 Pin 8  (PB1/SDA) <-> 4.7kΩ pull-up to 3.3V
 *   Teensy Pin 19 (SCL) <-> ATtiny804 Pin 9  (PB0/SCL) <-> 4.7kΩ pull-up to 3.3V
 *   Teensy Pin 2  (INT) <-> ATtiny804 Pin 7  (PB2/INT)
 *   GND <-> GND
 *   3.3V <-> VDD (ATtiny804)
 *
 * NOTE: Teensy 4.0 is 3.3V logic — use 3.3V pull-ups, not 5V.
 *       INT pin is active-low by default (idle HIGH, asserted LOW).
 */

#include <Wire.h>

#define SLAVE_ADDR      0x40
#define REG_ENC1_POS_L  0x00
#define REG_BUTTONS     0x06
#define REG_STATUS      0x07
#define REG_CMD         0x10
#define REG_INT_CFG     0x11

#define INT_PIN         2
#define POLL_INTERVAL   200   // fallback poll interval (ms) if INT is not wired

uint16_t rawEnc1 = 0;
uint16_t rawEnc2 = 0;
uint16_t rawEnc3 = 0;
uint8_t  buttons = 0;

uint16_t prevEnc1 = 0;
uint16_t prevEnc2 = 0;
uint16_t prevEnc3 = 0;

volatile bool intFired = false;

void intISR() {
  intFired = true;
}

bool readRegisters(uint8_t reg, uint8_t *buf, uint8_t len) {
  Wire.beginTransmission(SLAVE_ADDR);
  Wire.write(reg);
  if (Wire.endTransmission(false) != 0) return false;

  uint8_t received = Wire.requestFrom((uint8_t)SLAVE_ADDR, len);
  if (received != len) return false;

  for (uint8_t i = 0; i < len; i++) {
    buf[i] = Wire.read();
  }
  return true;
}

bool readEncoders() {
  uint8_t buf[7];
  if (!readRegisters(REG_ENC1_POS_L, buf, 7)) return false;

  rawEnc1 = (uint16_t)(buf[0] | (buf[1] << 8));
  rawEnc2 = (uint16_t)(buf[2] | (buf[3] << 8));
  rawEnc3 = (uint16_t)(buf[4] | (buf[5] << 8));
  buttons = buf[6];
  return true;
}

void setup() {
  Serial.begin(115200);
  Wire.begin();
  Wire.setClock(400000);

  pinMode(INT_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(INT_PIN), intISR, FALLING);

  delay(100);

  uint8_t status;
  if (readRegisters(REG_STATUS, &status, 1)) {
    Serial.print("ATtiny804 encoder slave found, firmware v");
    Serial.println(status);
  } else {
    Serial.println("ERROR: no response from slave at 0x40");
  }

  readEncoders();
  prevEnc1 = rawEnc1;
  prevEnc2 = rawEnc2;
  prevEnc3 = rawEnc3;
}

void loop() {
  static uint32_t lastPoll = 0;
  bool shouldRead = false;

  if (intFired) {
    intFired = false;
    shouldRead = true;
  }

  uint32_t now = millis();
  if (now - lastPoll >= POLL_INTERVAL) {
    lastPoll = now;
    shouldRead = true;
  }

  if (!shouldRead) return;

  if (readEncoders()) {
    int16_t delta1 = (int16_t)(rawEnc1 - prevEnc1);
    int16_t delta2 = (int16_t)(rawEnc2 - prevEnc2);
    int16_t delta3 = (int16_t)(rawEnc3 - prevEnc3);
    prevEnc1 = rawEnc1;
    prevEnc2 = rawEnc2;
    prevEnc3 = rawEnc3;

    if (delta1 != 0 || delta2 != 0 || delta3 != 0 || buttons != 0) {
      Serial.print("dE1: ");
      Serial.print(delta1);
      Serial.print("  dE2: ");
      Serial.print(delta2);
      Serial.print("  dE3: ");
      Serial.print(delta3);
      Serial.print("  BTN: ");
      Serial.print(buttons & 0x01 ? "1" : "0");
      Serial.print(",");
      Serial.println(buttons & 0x02 ? "1" : "0");
    }
  } else {
    Serial.println("I2C read failed");
  }
}
